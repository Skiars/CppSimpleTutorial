\section{模板和标准库}

回想一下，我们在 C 中实现一个判断两个对象大小的函数，一般要针对不同的类型编写不同的函数：
\begin{lstlisting}[language=c++]
// 求较大整数的函数
int max_int(int a, int b) {
    return a > b ? a : b;
}
// 求较大浮点数的函数
double max_double(double a, double b) {
    return a > b ? a : b;
}
// 使用宏实现的 max 算法
#define max_type(a, b)  ((a) > (b) ? (a) : (b))
\end{lstlisting}
前面两个 \texttt{max\_xxx} 函数的缺点非常明显：我们必须针对每种类型重新编写一份几乎一样的代码。而宏版本的缺点也很明显：容易对参数重复计算（宏本质是字符串替换），复杂功能极难维护。在 C++ 中我们可以使用 \textbf{模板} 来实现这种核心相同，但是要用于不同类型或者场合的算法。

\subsection{定义模板函数}

作为第一个例子，我们尝试通过 \textbf{模板函数} 实现上面的 \texttt{max} 函数：
\begin{lstlisting}[language=c++]
template <typename T>
T max(const T &a,  const T &b) {
    return a > b ? a : b;
}
\end{lstlisting}
模板的定义从 \textbf{\texttt{template}} 关键字开始，后面的尖括号对中是\textbf{模板参数列表}，多个模板参数之间使用逗号分隔。例子中的模板参数 \texttt{typename T} 定义了一个类型 \texttt{T}，它代表一个类型，并在模板被使用时被转换为一个实际的类型。我们通过这个模板的使用方法来说明模板参数：
\begin{lstlisting}[language=c++,numbers=none]
double v = max<double>(1.0, 3.0);
\end{lstlisting}
为了计算两个 \texttt{double} 值的最大者，需要指定 \texttt{double} 作为模板参数。为了生成目标代码，编译器会为 \texttt{max<double>} 生成这样的等效函数：
\begin{lstlisting}[language=c++]
// 使用 double 代替模板参数 T
double max<double>(const double &a, const double &b) {
    return a > b ? a : b;
}
\end{lstlisting}


我们还能举出一些例子，比如链表。链表的算法基本都是相同的，但是我们要在链表中存储不同的数据类型。对此一般有两种实现思路：
\begin{itemize}
  \item 数据类型必须派生自链表节点类，并通过结点类维护链表；
  \item 为每种数据类型实现链表算法。
\end{itemize}
第一种方法的思路在 C 中使用十分广泛，这种用法的缺点是需要侵入式修改并且须要使用指针来访问数据，使用上并不友好；第二种实现则不可能作为库中的代码。作为对比，我们看下 C++ 标准库中的链表使用方法：
\begin{lstlisting}[language=c++]
std::list<int> l;       // 定义存储 int 数据的链表
l.push_back(1);         // 在尾部插入 1
l.push_front(2);        // 在头部插入 2
l.insert(--l.end(), 3); // 在倒数第 2 个节点后插入 3
l.erase(++l.begin());   // 删除第二个元素
l.pop_back();           // 删除尾部元素
\end{lstlisting}
可以看出，标准库将链表的实现封装的非常好，这些代码看起来就是在一种``容器''中操作我们存储的 \texttt{int} 数据，而不用关心这些数据是怎样被存储的，因此容易使用。

在 C++ 中，通过模板可以将一份代码用于不同的类型或某些场景
