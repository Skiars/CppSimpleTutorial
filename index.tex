\documentclass[hyperref,UTF8]{article}
\usepackage{hyperref}
\usepackage{ctex}
\usepackage{subfigure}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage[ruled]{algorithm2e}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}

\setCJKmainfont[BoldFont=FZHei-B01S, ItalicFont=FZKai-Z03S]{FZShuSong-Z01S}
\setCJKmonofont{FZFangSong-Z02S}
\setCJKsansfont{FZKai-Z03S}
\ziju{0.06} % 字间距

\geometry{a4paper,scale=0.8}

\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}

\hypersetup{
  colorlinks=false,
  pdfborder=0 0 0
}

\lstset{
  basicstyle=\ttfamily\small,
  numbers=left,numberstyle=\ttfamily\small,
  columns=fullflexible,
  %xleftmargin=\parindent,
  commentstyle=\color{green!50!black}\itshape,
  keywordstyle=\color{cyan!50!black}\bfseries,
  stringstyle=\color{purple},
  numberstyle=\ttfamily\color{gray},
}

\usetikzlibrary{automata,positioning,topaths,arrows}

\bibliographystyle{plain}

\begin{document}

\title{C++ 极简入门}
\author{Skiars}

{\bfseries\maketitle}

这篇教程的目的是帮助了解 C 语言，但是对 C++ 不熟悉的人快速入门并能够在实际开发中使用该语言。本教程不试图让读者理解 C++ 的各种语法细节，而是介绍实际开发中常用的一些特性以及那些被广泛使用的技术和技巧。本教程介绍的一些技术可以有效地减少可能的错误，而这些技术使用 C++ 很容易实现，并且不需要高深的知识。

\setcounter{tocdepth}{2}
\tableofcontents

\section{认识 C++}

\subsection{编程范式}

大部分有 C 语言基础的读者对 C++ 的第一印象是``带类的 C''，也就是将 C++ 作为 C 的面向对象版本的超集。不过这种认认知并不全面，因为 C++ 支持多种编程范式，例如面向过程、面向对象和范型编程等。实际的 C++ 项目更可能混合使用多种编程范式，也就是所谓的 ``多范型编程''。C++ 的设计者希望为用户提供尽可能多的选择并让后者选择自己需要的特性（同时只需要学习你需要的特性也就足够了）。

很多 C 程序员对面向对象编程并不陌生。例如定义一种通用的 IO Reader 模块用于文本解析器的输入接口，该模块的结构体中有一个 \texttt{read} 函数指针用于读取字节，然后我们可以封装基于文件或者网络的 Reader 模块。这样，文本解析器只需要接受一个 IO Reader 结构指针即可对接到各种实际的读取接口。这个例子是典型的面向对象思想，值得一提的是，面向对象技术在 C 程序中有广泛的使用，不过 C++ 对面向对象有语言层面的支持。

C++ 的另一个重要的编程范式是范型编程，这里还是举一个简单的例子：假设我们实现了一种排序算法，在 C 的版本中一般要针对每种类型（例如整数和字符串）实现该算法，但是在 C++ 中可以借助模板和运算符重载等技术可以只编写一次排序算法。

\subsection{C++ 设计思想}

我认为在一开始就了解 C++ 的设计思想是非常有必要的，尤其是如果读者有丰富的开发经验，就会了解该语言试图解决的一些问题。

文献 \cite{BjarneStroustrup2002C} 第 4 章介绍了 C++ 语言的基本设计规则。其中一些规则摘录如下（建议阅读原书）：

\begin{itemize}
  \item C++ 的发展必须由实际问题推动
  \item 为每种应该支持的风格提供全面的支持
  \item 总提供一条转变的通路
  \item 不试图去强迫人做什么
  \item 为程序的组织提供各种机制
  \item 允许一个有用的特种比防止各种错误更为重要
  \item 局部化是好事情
  \item 对不用的东西不需要付出代价（零开销规则）
\end{itemize}

C++ 是一种从实际工程需求出发的语言，

\section{基础知识}

\subsection{函数重载}

\section{作用域和命名空间} \label{sec:scope}



\section{类}

在 C 语言中，我们可以通过结构体定义数据类型，而 C++ 中则引入了 \textbf{类}。从实现上来看，一个类由若干数据成员和方法（用于操作数据成员的函数）构成，仅从这一点上来看，类和 C 结构体配合专用操作函数非常相似。但是类提供了\textbf{访问控制}的功能，下面我们通过一个例子简单说明：
\begin{lstlisting}[language=c++]
class Point {
public:
    int x() { return _x; }
    int y() { return _y; }
    void setX(int x) { _x = int(x); }
    void setY(int y) { _y = int(y); }
private:
    short _x, _y;
};
Point p;   // 定义Point对象p
p.setX(2); // 正确
p._x = 3;  // 编译报错（私有成员在类外部不可见）
\end{lstlisting}
\texttt{Point} 类用于表示二维平面中的点，在 GUI 等场合中非常常见。这个例子中我们分别实现了设置和获取 $(x, y)$ 坐标的方法，这些方法处于 \texttt{public} 说明符下，因此外部代码可以访问和调用，而坐标数据则存储在 \texttt{private} 说明符下，只有 \texttt{Point} 类内部可以访问。这里我们故意将坐标存储为 \texttt{short} 类型（常见的 GUI 坐标使用 \texttt{short} 完全足够），这样和使用 C 结构体相比，有以下好处：
\begin{itemize}
  \item 坐标存储为 \texttt{short} 类型，节约空间；
  \item \texttt{x()}，\texttt{setX()} 方法操作的类型都是 \texttt{int}，使用上比较通用（乘法运算时 \texttt{short} 有溢出风险，并且人们更习惯 \texttt{int}）；
  \item 如果有一天我们确实需要将坐标升级为 \texttt{int} 类型，那么修改第 9 行代码即可，客户代码完全不用改。
\end{itemize}
总而言之，上面例子最大的意义在于，用户可以使用通用的接口来操作一个对象（类），而对象的实现细节和数据抽象对用户并不可见。在面向对象的程序设计中，我们一般不会直接把数据成员作为公共的属性暴露给用户。假设类本身封装有数据成员的复杂操作，暴露数据成员不仅作用不大，还不利于封装实现细节。

\subsection{成员函数（方法）}

类的成员函数又称为\textbf{方法}，用于操作类的数据成员并负责接口实现。类的成员函数必须在类内部声明，正如 \texttt{Point} 类的哪些方法。我们还可以在类外面定义成员函数：
\begin{lstlisting}[language=c++]
class Point {
public:
    int x();
    // ...
};
int Point::x() { return _x; }
\end{lstlisting}
第 6 行在 \texttt{Point} 定义的外部定义了 \texttt{Point::x} 成员函数。\texttt{::} 为作用域运算符，在 \ref{sec:scope} 节会说明。

\subsubsection{\texttt{this} 指针}

类的实例指针通过一个名为 \textbf{\texttt{this}} 的隐式参数传递给成员函数以访问调用的对象。当我们调用 \texttt{p.setX(2)} 时，编译器会将对象 \texttt{p} 的地址通过 \texttt{this} 指针传递给 \texttt{setX}，从而访问数据成员 \texttt{\_x}，我们可以在成员函数中显示使用 \texttt{this} 指针：
\begin{lstlisting}[language=c++]
int Point::x() { return this->_x; }
\end{lstlisting}
一般可以像前面的例子一样隐式地使用用 \texttt{this} 指针，但如果类的成员和某些参数或者全局变量重名，\texttt{this} 指针会很有用。另外，\texttt{this} 是常量指针并总是指向当前对象，不能修改。

\texttt{const 成员函数}

回想我们在 C 语言中定义的常量变量：
\begin{lstlisting}[language=c++]
const int x = 1;
\end{lstlisting}
很显然不能在定义 \texttt{x} 变量之后修改它的值。现在我们看 C++ 的例子：
\begin{lstlisting}[language=c++]
int length(const Point *p) {
  return (int)sqrt(p->x() * p->x() + p->y() * p->y());
}
Point p;
p.setX(3);
p.setY(4);
length(&p); // 应该返回 5
\end{lstlisting}
\texttt{length} 函数用于求二维向量的长度，这个函数不需要修改参数 \texttt{p} 的值（不修改它的数据成员），因此将参数 \texttt{p} 加上了 \texttt{const} 修饰。不过上面的代码编译会报错，原因在于：虽然 \texttt{Point::x()} 和 \texttt{Point::y()} 虽然事实上不修改 \texttt{Point} 对象的值，但是编译器并不知道。我们可以将上述成员函数的定义后加上 \texttt{const} 关键字以指出此成员函数不会修改对象（此时 \texttt{this} 指针是 \texttt{const Point* const} 类型）：
\begin{lstlisting}[language=c++]
class Point {
public:
    int x() const { return _x; }
    int y() const { return _y; }
    // ...
};
\end{lstlisting}
这种成员函数称为\textbf{常量成员函数}。如果可以，应尽量定义常量成员函数。

\subsubsection{\texttt{const} 成员函数}

\subsection{构造函数和析构函数}

类使用称为\textbf{构造函数}的成员函数定义对象的初始化方式。类被创建时总会调用构造函数。构造函数的名字和类名相同，没有返回类型，并可能有零到多个参数列表。一个类可以具有多个构造函数，不同构造函数的参数类型或者数量必须不同。构造函数不能声明为 \texttt{const} 的。

\subsubsection{定义构造函数}

对于前面的 \texttt{Point}，我们将考虑两个重载版本：一个版本不接受任何参数，将点初始化 $(0,0)$；另一个版本接受一对 $(x,y)$ 值并初始化点：
\begin{lstlisting}[language=c++]
class Point {
public:
    Point() { _x = 0; _y = 0; }
    Point(int x, int y) { _x = (int)x; _y = (int)y; }
    // ...
};
\end{lstlisting}
我们还可以使用构造函数的初始值列表直接初始化成员变量：
\begin{lstlisting}[language=c++]
class Point {
public:
    Point() : _x(), _y() {}
    Point(int x, int y) : _x(x), _y(y) {}
    // ...
};
\end{lstlisting}
在冒号和花括号之间的代码就是初始值列表。

\subsection{运算符重载}

\subsection{继承}

\section{内存管理}

\section{模板和标准库}

\bibliography{references}

\end{document}
